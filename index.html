<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe - Кіберпанк</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --neon-cyan: #0ff;
            --neon-pink: #f0f;
            --neon-purple: #906cff;
            --neon-green: #0f0;
            --neon-yellow: #ff0;
            --dark-bg: #0a0a16;
            --darker-bg: #050510;
            --grid-color: #1a1a2e;
        }

        body {
            background: var(--darker-bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            color: white;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        /* Scanlines effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.03) 0px,
                transparent 1px,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 3px
            );
            pointer-events: none;
            z-index: 1;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }

        .container {
            width: 100%;
            max-width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px var(--neon-cyan);
            margin-bottom: 5px;
            letter-spacing: 3px;
            animation: glitchTitle 3s infinite;
        }

        @keyframes glitchTitle {
            0%, 90%, 100% { transform: translate(0); }
            91% { transform: translate(-2px, 2px); }
            93% { transform: translate(2px, -2px); }
            95% { transform: translate(0); }
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            letter-spacing: 2px;
        }

        /* Language selector */
        .language-selector {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 8px;
        }

        .lang-btn {
            background: rgba(20, 20, 40, 0.7);
            border: 1px solid var(--neon-purple);
            color: var(--neon-cyan);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.3s ease;
        }

        .lang-btn.active {
            background: rgba(144, 108, 255, 0.5);
            box-shadow: 0 0 10px var(--neon-purple);
        }

        .lang-btn:hover {
            background: rgba(144, 108, 255, 0.3);
        }

        /* Game mode selector */
        .game-mode-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 10px 20px;
            background: rgba(20, 20, 40, 0.7);
            border: 2px solid var(--neon-purple);
            border-radius: 6px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 140px;
            text-align: center;
        }

        .mode-btn.active {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        .mode-btn:hover {
            background: rgba(144, 108, 255, 0.2);
            transform: translateY(-2px);
        }

        /* AI Progress */
        .ai-progress {
            width: 100%;
            height: 4px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 0.7rem;
            text-align: center;
            margin-top: 5px;
            color: var(--neon-cyan);
        }

        /* Tutorial button */
        .tutorial-btn {
            padding: 8px 16px;
            background: rgba(144, 108, 255, 0.3);
            border: 1px solid var(--neon-purple);
            border-radius: 6px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .tutorial-btn:hover {
            background: rgba(144, 108, 255, 0.5);
            box-shadow: 0 0 15px var(--neon-purple);
        }

        /* Game info panel */
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            gap: 15px;
            margin-bottom: 15px;
        }

        .info-panel {
            flex: 1;
            padding: 15px;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 8px;
            border: 1px solid var(--neon-purple);
            box-shadow: 0 0 10px rgba(144, 108, 255, 0.3);
            text-align: center;
        }

        .player-turn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .player-icon {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .player-x {
            background: var(--neon-cyan);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        .player-o {
            background: var(--neon-pink);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .ai-thinking {
            background: var(--neon-yellow);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-yellow);
            animation: aiPulse 1s infinite;
        }

        @keyframes aiPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        .score-display {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .score-item {
            text-align: center;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }

        .score-label {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        /* Main game board */
        .mega-board {
            width: 100%;
            max-width: 650px;
            aspect-ratio: 1/1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            background: var(--darker-bg);
            padding: 15px;
            border-radius: 12px;
            border: 3px solid var(--neon-purple);
            box-shadow: 
                0 0 30px rgba(144, 108, 255, 0.5),
                inset 0 0 30px rgba(0, 0, 0, 0.6);
        }

        /* Local board (each small 3x3) */
        .local-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            background: var(--grid-color);
            padding: 6px;
            border-radius: 8px;
            border: 2px solid rgba(144, 108, 255, 0.4);
            position: relative;
            transition: all 0.3s ease;
        }

        .local-board.active {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 25px var(--neon-yellow), inset 0 0 15px rgba(255, 255, 0, 0.2);
            animation: activeBoardPulse 1.5s infinite;
        }

        @keyframes activeBoardPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .local-board.won {
            pointer-events: none;
        }

        .local-board.won::before {
            content: attr(data-winner);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: 900;
            opacity: 0.3;
            z-index: 10;
            animation: wonAppear 0.5s ease-out;
        }

        .local-board.won-x::before {
            color: var(--neon-cyan);
            text-shadow: 0 0 30px var(--neon-cyan);
        }

        .local-board.won-o::before {
            color: var(--neon-pink);
            text-shadow: 0 0 30px var(--neon-pink);
        }

        @keyframes wonAppear {
            from { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.3; }
        }

        .local-board.won-x {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-cyan);
        }

        .local-board.won-o {
            background: rgba(255, 0, 255, 0.1);
            border-color: var(--neon-pink);
        }

        .local-board.tied {
            background: rgba(128, 128, 128, 0.2);
            border-color: #666;
            pointer-events: none;
        }

        .local-board.tied::before {
            content: '—';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10rem;
            font-weight: 900;
            color: #666;
            opacity: 0.3;
            z-index: 10;
        }

        /* Individual cells */
        .cell {
            background: rgba(20, 20, 40, 0.9);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(144, 108, 255, 0.3);
            position: relative;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .cell:hover:not(.x):not(.o)::before {
            width: 100%;
            height: 100%;
        }

        .cell:hover:not(.x):not(.o) {
            transform: scale(1.1);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        .cell.x, .cell.o {
            animation: cellAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: default;
        }

        @keyframes cellAppear {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .cell.x {
            color: var(--neon-cyan);
            text-shadow: 0 0 15px var(--neon-cyan);
        }

        .cell.o {
            color: var(--neon-pink);
            text-shadow: 0 0 15px var(--neon-pink);
        }

        .cell.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Status message */
        .status-message {
            font-size: 1.1rem;
            font-weight: 700;
            text-align: center;
            min-height: 40px;
            padding: 12px 24px;
            border-radius: 8px;
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid var(--neon-purple);
            box-shadow: 0 0 20px rgba(144, 108, 255, 0.4);
            width: 100%;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            transition: all 0.3s ease;
        }

        .status-message.win {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
            color: var(--neon-green);
            animation: statusGlitch 2s infinite;
            font-size: 1.3rem;
        }

        .status-message.ai-thinking {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 20px var(--neon-yellow);
            color: var(--neon-yellow);
            animation: thinkingPulse 1.5s infinite;
        }

        @keyframes thinkingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes statusGlitch {
            0%, 94%, 100% { transform: translate(0); }
            95% { transform: translate(-3px, 3px); }
            97% { transform: translate(3px, -3px); }
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            flex-wrap: wrap;
        }

        .cyber-button {
            flex: 1;
            min-width: 140px;
            padding: 14px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .cyber-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .cyber-button:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-purple), #6a00ff);
            color: white;
            box-shadow: 0 0 20px rgba(144, 108, 255, 0.5);
            border: 2px solid var(--neon-cyan);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 25px rgba(144, 108, 255, 0.8);
        }

        .btn-secondary {
            background: rgba(20, 20, 40, 0.8);
            color: var(--neon-cyan);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        /* Difficulty selector */
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .diff-btn {
            padding: 8px 16px;
            background: rgba(20, 20, 40, 0.5);
            border: 1px solid var(--neon-purple);
            border-radius: 4px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }

        .diff-btn.active {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        .diff-btn:hover {
            background: rgba(144, 108, 255, 0.2);
        }

        /* Tutorial modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--dark-bg);
            border: 2px solid var(--neon-purple);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(144, 108, 255, 0.6);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-header {
            font-size: 1.8rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-body {
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
        }

        .modal-body h3 {
            color: var(--neon-pink);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-body ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .modal-body li {
            margin-bottom: 8px;
        }

        .modal-close {
            margin-top: 20px;
            width: 100%;
        }

        .highlight {
            color: var(--neon-yellow);
            font-weight: bold;
        }

        /* Responsive */
        @media (max-width: 700px) {
            h1 { font-size: 1.8rem; }
            .subtitle { font-size: 0.75rem; }
            .mega-board { gap: 10px; padding: 10px; }
            .local-board { gap: 3px; padding: 4px; }
            .cell { font-size: 1.4rem; }
            .local-board.won::before { font-size: 5rem; }
            .game-info { flex-direction: column; }
            .language-selector { position: static; margin-bottom: 10px; }
            .game-mode-selector { flex-direction: column; }
            .mode-btn { min-width: 100%; }
        }

        @media (max-width: 480px) {
            .mega-board { gap: 8px; padding: 8px; max-width: 100%; }
            .local-board { gap: 2px; padding: 3px; }
            .cell { font-size: 1.2rem; }
            .local-board.won::before { font-size: 4rem; }
            .controls { flex-direction: column; }
            .cyber-button { min-width: 100%; }
            .difficulty-selector { flex-direction: column; }
            .diff-btn { min-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="language-selector">
                <button class="lang-btn active" data-lang="uk">UA</button>
                <button class="lang-btn" data-lang="en">EN</button>
            </div>
            <h1 data-uk="ULTIMATE TIC-TAC-TOE" data-en="ULTIMATE TIC-TAC-TOE">ULTIMATE TIC-TAC-TOE</h1>
            <div class="subtitle" data-uk="КІБЕРПАНК ВЕРСІЯ" data-en="CYBERPUNK EDITION">КІБЕРПАНК ВЕРСІЯ</div>
            
            <!-- Game Mode Selector -->
            <div class="game-mode-selector">
                <button class="mode-btn active" data-mode="twoPlayers" data-uk="👥 Два гравці" data-en="👥 Two Players">👥 Два гравці</button>
                <button class="mode-btn" data-mode="vsAI" data-uk="🤖 Гра з AI" data-en="🤖 VS AI">🤖 Гра з AI</button>
            </div>

            <!-- Difficulty Selector (visible only in AI mode) -->
            <div class="difficulty-selector" id="difficultySelector" style="display: none;">
                <button class="diff-btn active" data-diff="easy" data-uk="😊 Легкий" data-en="😊 Easy">😊 Легкий</button>
                <button class="diff-btn" data-diff="medium" data-uk="😐 Середній" data-en="😐 Medium">😐 Середній</button>
                <button class="diff-btn" data-diff="hard" data-uk="😈 Складний" data-en="😈 Hard">😈 Складний</button>
                <button class="diff-btn" data-diff="expert" data-uk="🧠 Експерт" data-en="🧠 Expert">🧠 Експерт</button>
                <button class="diff-btn" data-diff="master" data-uk="🏆 Майстер" data-en="🏆 Master">🏆 Майстер</button>
            </div>

            <!-- AI Progress -->
            <div class="ai-progress" id="aiProgress">
                <div class="ai-progress-bar" id="aiProgressBar"></div>
                <div class="progress-text" id="progressText">AI аналізує...</div>
            </div>

            <button class="tutorial-btn" id="tutorialBtn" data-uk="📖 Як грати?" data-en="📖 How to play?">📖 Як грати?</button>
        </div>

        <!-- Game Info -->
        <div class="game-info">
            <div class="info-panel">
                <div class="player-turn">
                    <div class="player-icon player-x">X</div>
                    <div>
                        <div style="font-size: 0.9rem; opacity: 0.8;" data-uk="Зараз грає" data-en="Current player">Зараз грає</div>
                        <div id="currentPlayerText" style="font-size: 1.2rem; font-weight: bold;" data-uk="Гравець X" data-en="Player X">Гравець X</div>
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <div style="font-size: 0.8rem; opacity: 0.8; margin-bottom: 8px;" data-uk="РАХУНОК" data-en="SCORE">РАХУНОК</div>
                <div class="score-display">
                    <div class="score-item">
                        <div class="score-value" id="scoreX">0</div>
                        <div class="score-label">X</div>
                    </div>
                    <div class="score-item">
                        <div class="score-value" id="scoreO">0</div>
                        <div class="score-label">O</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Message -->
        <div class="status-message" id="status" data-uk="Гравець X може зробити хід в будь-якій дошці" data-en="Player X can move in any board">
            Гравець X може зробити хід в будь-якій дошці
        </div>

        <!-- Main Game Board -->
        <div class="mega-board" id="megaBoard"></div>

        <!-- Controls -->
        <div class="controls">
            <button class="cyber-button btn-primary" id="resetBtn">
                <span data-uk="🔄 Нова гра" data-en="🔄 New Game">🔄 Нова гра</span>
            </button>
            <button class="cyber-button btn-secondary" id="rulesBtn">
                <span data-uk="📜 Правила" data-en="📜 Rules">📜 Правила</span>
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content">
            <div class="modal-header" data-uk="🎮 Як грати в Ultimate Tic-Tac-Toe" data-en="🎮 How to play Ultimate Tic-Tac-Toe">
                🎮 Як грати в Ultimate Tic-Tac-Toe
            </div>
            <div class="modal-body">
                <h3 data-uk="🎯 Мета гри" data-en="🎯 Game Objective">🎯 Мета гри</h3>
                <p data-uk="Виграти три малі дошки поспіль (горизонтально, вертикально або діагонально) на великій дошці 3×3." data-en="Win three small boards in a row (horizontally, vertically or diagonally) on the large 3×3 board.">
                    Виграти <span class="highlight">три малі дошки поспіль</span> (горизонтально, вертикально або діагонально) на великій дошці 3×3.
                </p>

                <h3 data-uk="📋 Правила" data-en="📋 Rules">📋 Правила</h3>
                <ul>
                    <li data-uk="Перший хід: Гравець X починає і може зробити хід в будь-якій клітинці будь-якої малої дошки." data-en="First move: Player X starts and can move in any cell of any small board.">
                        <strong data-uk="Перший хід:" data-en="First move:">Перший хід:</strong> <span data-uk="Гравець X починає і може зробити хід в будь-якій клітинці будь-якої малої дошки." data-en="Player X starts and can move in any cell of any small board.">Гравець X починає і може зробити хід в будь-якій клітинці будь-якої малої дошки.</span>
                    </li>
                    
                    <li data-uk="Наступні ходи: Позиція вашого ходу визначає, в якій малій дошці має ходити наступний гравець." data-en="Next moves: Your move position determines in which small board the next player must play.">
                        <strong data-uk="Наступні ходи:" data-en="Next moves:">Наступні ходи:</strong> <span data-uk="Позиція вашого ходу визначає, в якій малій дошці має ходити наступний гравець." data-en="Your move position determines in which small board the next player must play.">Позиція вашого ходу визначає, <span class="highlight">в якій малій дошці має ходити наступний гравець</span>.</span>
                    </li>
                    
                    <li data-uk="Приклад: Якщо ви зробили хід у верхньому правому кутку малої дошки, наступний гравець ПОВИНЕН зробити хід у верхній правій малій дошці." data-en="Example: If you move in the top-right corner of a small board, the next player MUST play in the top-right small board.">
                        <strong data-uk="Приклад:" data-en="Example:">Приклад:</strong> <span data-uk="Якщо ви зробили хід у верхньому правому кутку малої дошки, наступний гравець ПОВИНЕН зробити хід у верхній правій малій дошці." data-en="If you move in the top-right corner of a small board, the next player MUST play in the top-right small board.">Якщо ви зробили хід у верхньому правому кутку малої дошки, наступний гравець ПОВИНЕН зробити хід у верхній правій малій дошці.</span>
                    </li>
                    
                    <li data-uk="Виграш малої дошки: Виграйте малу дошку, поставивши три свої символи поспіль (як у звичайних хрестиках-ноликах)." data-en="Winning a small board: Win a small board by placing three of your symbols in a row (like regular tic-tac-toe).">
                        <strong data-uk="Виграш малої дошки:" data-en="Winning a small board:">Виграш малої дошки:</strong> <span data-uk="Виграйте малу дошку, поставивши три свої символи поспіль (як у звичайних хрестиках-ноликах)." data-en="Win a small board by placing three of your symbols in a row (like regular tic-tac-toe).">Виграйте малу дошку, поставивши три свої символи поспіль (як у звичайних хрестиках-ноликах).</span>
                    </li>
                    
                    <li data-uk="Заповнена дошка: Якщо вас відправляють на вже виграну або нічийну дошку, ви можете зробити хід на будь-якій доступній дошці." data-en="Full board: If you're sent to an already won or tied board, you can move in any available board.">
                        <strong data-uk="Заповнена дошка:" data-en="Full board:">Заповнена дошка:</strong> <span data-uk="Якщо вас відправляють на вже виграну або нічийну дошку, ви можете зробити хід на будь-якій доступній дошці." data-en="If you're sent to an already won or tied board, you can move in any available board.">Якщо вас відправляють на вже виграну або нічийну дошку, ви можете зробити хід на будь-якій доступній дошці.</span>
                    </li>
                    
                    <li data-uk="Нічия: Якщо мала дошка заповнена без переможця, вона вважається нічиєю (сірою)." data-en="Tie: If a small board is filled without a winner, it's considered a tie (gray).">
                        <strong data-uk="Нічия:" data-en="Tie:">Нічия:</strong> <span data-uk="Якщо мала дошка заповнена без переможця, вона вважається нічиєю (сірою)." data-en="If a small board is filled without a winner, it's considered a tie (gray).">Якщо мала дошка заповнена без переможця, вона вважається нічиєю (сірою).</span>
                    </li>
                </ul>

                <h3 data-uk="🎮 Режими гри" data-en="🎮 Game Modes">🎮 Режими гри</h3>
                <ul>
                    <li data-uk="👥 Два гравці: Класичний режим для гри з другом" data-en="👥 Two Players: Classic mode to play with a friend">👥 <strong>Два гравці:</strong> Класичний режим для гри з другом</li>
                    <li data-uk="🤖 Гра з AI: Гра проти штучного інтелекту з п'ятьма рівнями складності" data-en="🤖 VS AI: Play against artificial intelligence with five difficulty levels">🤖 <strong>Гра з AI:</strong> Гра проти штучного інтелекту з п'ятьма рівнями складності</li>
                </ul>

                <h3 data-uk="💡 Підказки" data-en="💡 Tips">💡 Підказки</h3>
                <ul>
                    <li data-uk="Думайте наперед! Ваш хід визначає, де гратиме суперник." data-en="Think ahead! Your move determines where your opponent will play.">Думайте наперед! Ваш хід визначає, де гратиме суперник.</li>
                    <li data-uk="Намагайтеся контролювати центральну дошку." data-en="Try to control the center board.">Намагайтеся контролювати центральну дошку.</li>
                    <li data-uk="Жовта підсвітка показує активну дошку." data-en="Yellow highlight shows the active board."><span class="highlight" data-uk="Жовта підсвітка" data-en="Yellow highlight">Жовта підсвітка</span> <span data-uk="показує активну дошку." data-en="shows the active board.">показує активну дошку.</span></li>
                    <li data-uk="Стратегія набагато важливіша, ніж у звичайних хрестиках-ноликах!" data-en="Strategy is much more important than in regular tic-tac-toe!">Стратегія набагато важливіша, ніж у звичайних хрестиках-ноликах!</li>
                </ul>

                <h3 data-uk="🎨 Легенда" data-en="🎨 Legend">🎨 Легенда</h3>
                <ul>
                    <li><span style="color: var(--neon-cyan);">🔵 <span data-uk="Блакитний X" data-en="Blue X">Блакитний X</span></span> — <span data-uk="символ гравця X" data-en="symbol of player X">символ гравця X</span></li>
                    <li><span style="color: var(--neon-pink);">🔴 <span data-uk="Рожевий O" data-en="Pink O">Рожевий O</span></span> — <span data-uk="символ гравця O" data-en="symbol of player O">символ гравця O</span></li>
                    <li><span style="color: var(--neon-yellow);">🟡 <span data-uk="Жовта рамка" data-en="Yellow border">Жовта рамка</span></span> — <span data-uk="активна дошка" data-en="active board">активна дошка</span></li>
                    <li><span style="color: #666;">⚪ <span data-uk="Сіра дошка" data-en="Gray board">Сіра дошка</span></span> — <span data-uk="нічия" data-en="tie">нічия</span></li>
                </ul>
            </div>
            <button class="cyber-button btn-primary modal-close" id="closeModal" data-uk="Зрозуміло, починаємо!" data-en="Got it, let's start!">
                Зрозуміло, починаємо!
            </button>
        </div>
    </div>

    <script>
        // ============================================
        // ADVANCED MCTS AI PLAYER
        // ============================================
        class MCTSNode {
            constructor(state, parent = null, move = null) {
                this.state = state;
                this.parent = parent;
                this.move = move;
                this.children = [];
                this.wins = 0;
                this.visits = 0;
                this.untriedMoves = state.getLegalMoves();
            }

            selectChild() {
                let bestChild = this.children[0];
                let bestValue = -Infinity;

                for (const child of this.children) {
                    if (child.visits === 0) {
                        return child;
                    }
                    
                    const exploitation = child.wins / child.visits;
                    const exploration = Math.sqrt(2 * Math.log(this.visits) / child.visits);
                    const ucbValue = exploitation + exploration;
                    
                    if (ucbValue > bestValue) {
                        bestValue = ucbValue;
                        bestChild = child;
                    }
                }
                
                return bestChild;
            }

            addChild(move, state) {
                const child = new MCTSNode(state, this, move);
                this.untriedMoves = this.untriedMoves.filter(m => 
                    !(m.boardIndex === move.boardIndex && m.cellIndex === move.cellIndex)
                );
                this.children.push(child);
                return child;
            }

            update(result) {
                this.visits++;
                this.wins += result;
            }
        }

        class MCTSPlayer {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.symbol = 'O';
                this.opponentSymbol = 'X';
                this.setDifficulty(difficulty);
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                switch(difficulty) {
                    case 'easy':
                        this.iterations = 200;
                        this.timeLimit = 1000;
                        break;
                    case 'medium':
                        this.iterations = 800;
                        this.timeLimit = 2000;
                        break;
                    case 'hard':
                        this.iterations = 1500;
                        this.timeLimit = 3500;
                        break;
                    case 'expert':
                        this.iterations = 3000;
                        this.timeLimit = 5000;
                        break;
                    case 'master':
                        this.iterations = 100000;
                        this.timeLimit = 30000;
                        break;
                    default:
                        this.iterations = 800;
                        this.timeLimit = 2000;
                }
            }

            getMove(gameState, progressCallback = null) {
                const root = new MCTSNode(gameState);
                const startTime = Date.now();
                let iterations = 0;

                while (iterations < this.iterations && 
                       (Date.now() - startTime) < this.timeLimit) {
                    
                    let node = root;
                    let state = gameState.clone();

                    // Selection
                    while (node.untriedMoves.length === 0 && node.children.length > 0) {
                        node = node.selectChild();
                        state.makeMove(node.move);
                    }

                    // Expansion
                    if (node.untriedMoves.length > 0) {
                        const move = node.untriedMoves[
                            Math.floor(Math.random() * node.untriedMoves.length)
                        ];
                        state.makeMove(move);
                        node = node.addChild(move, state);
                    }

                    // Simulation
                    let simulationState = state.clone();
                    while (!simulationState.isTerminal()) {
                        const moves = simulationState.getLegalMoves();
                        if (moves.length === 0) break;
                        const randomMove = moves[Math.floor(Math.random() * moves.length)];
                        simulationState.makeMove(randomMove);
                    }

                    // Backpropagation
                    const result = this.getResult(simulationState);
                    while (node !== null) {
                        node.update(result);
                        node = node.parent;
                    }

                    iterations++;
                    
                    // Update progress
                    if (progressCallback && iterations % 50 === 0) {
                        const progress = Math.min(100, 
                            Math.max(
                                (iterations / this.iterations) * 100,
                                ((Date.now() - startTime) / this.timeLimit) * 100
                            )
                        );
                        progressCallback(progress, iterations);
                    }
                }

                // Select best move (most visited)
                let bestChild = root.children[0];
                for (const child of root.children) {
                    if (child.visits > bestChild.visits) {
                        bestChild = child;
                    }
                }

                console.log(`MCTS: ${iterations} iterations, best move visits: ${bestChild ? bestChild.visits : 0}`);
                return bestChild ? bestChild.move : null;
            }

            getResult(state) {
                const winner = state.getWinner();
                if (winner === this.symbol) return 1;
                if (winner === this.opponentSymbol) return 0;
                if (winner === 'tie') return 0.5;
                
                return 0.5; // Neutral for non-terminal states
            }
        }

        // ============================================
        // GAME STATE FOR MCTS
        // ============================================
        class MCTSGameState {
            constructor(localBoards, localBoardsStatus, currentPlayer, activeBoard) {
                this.localBoards = this.deepCopy(localBoards);
                this.localBoardsStatus = [...localBoardsStatus];
                this.currentPlayer = currentPlayer;
                this.activeBoard = activeBoard;
            }

            clone() {
                return new MCTSGameState(
                    this.localBoards,
                    this.localBoardsStatus,
                    this.currentPlayer,
                    this.activeBoard
                );
            }

            deepCopy(boards) {
                return boards.map(board => [...board]);
            }

            getLegalMoves() {
                const moves = [];
                
                const playableBoards = this.activeBoard === null ? 
                    this.localBoardsStatus.map((status, index) => status === '' ? index : -1).filter(i => i !== -1) :
                    [this.activeBoard];

                playableBoards.forEach(boardIndex => {
                    if (this.localBoardsStatus[boardIndex] === '') {
                        for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                            if (this.localBoards[boardIndex][cellIndex] === '') {
                                moves.push({ boardIndex, cellIndex });
                            }
                        }
                    }
                });

                return moves;
            }

            makeMove(move) {
                const { boardIndex, cellIndex } = move;
                
                this.localBoards[boardIndex][cellIndex] = this.currentPlayer;

                const localWinner = this.checkLocalBoardWinner(boardIndex);
                if (localWinner) {
                    this.localBoardsStatus[boardIndex] = localWinner;
                } else if (this.isLocalBoardFull(boardIndex)) {
                    this.localBoardsStatus[boardIndex] = 'tie';
                }

                this.activeBoard = this.localBoardsStatus[cellIndex] === '' ? cellIndex : null;
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
            }

            isTerminal() {
                return this.getWinner() !== null;
            }

            getWinner() {
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];

                for (const [a, b, c] of patterns) {
                    if (this.localBoardsStatus[a] && 
                        this.localBoardsStatus[a] === this.localBoardsStatus[b] && 
                        this.localBoardsStatus[a] === this.localBoardsStatus[c]) {
                        return this.localBoardsStatus[a];
                    }
                }

                if (this.localBoardsStatus.every(status => status !== '')) {
                    return 'tie';
                }

                return null;
            }

            checkLocalBoardWinner(boardIndex) {
                const board = this.localBoards[boardIndex];
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];

                for (const [a, b, c] of patterns) {
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a];
                    }
                }
                return null;
            }

            isLocalBoardFull(boardIndex) {
                return this.localBoards[boardIndex].every(cell => cell !== '');
            }
        }

        // ============================================
        // LANGUAGE MANAGER
        // ============================================
        class LanguageManager {
            constructor() {
                this.currentLang = 'uk';
                this.init();
            }
            
            init() {
                const savedLang = localStorage.getItem('ultimateTicTacToeLang');
                if (savedLang) {
                    this.currentLang = savedLang;
                }
                
                this.setupEventListeners();
                this.applyLanguage();
            }
            
            setupEventListeners() {
                const langButtons = document.querySelectorAll('.lang-btn');
                langButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const lang = btn.dataset.lang;
                        this.setLanguage(lang);
                    });
                });
            }
            
            setLanguage(lang) {
                this.currentLang = lang;
                localStorage.setItem('ultimateTicTacToeLang', lang);
                this.applyLanguage();
                
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
            }
            
            applyLanguage() {
                const elements = document.querySelectorAll('[data-uk], [data-en]');
                elements.forEach(element => {
                    if (element.dataset[this.currentLang]) {
                        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                            element.placeholder = element.dataset[this.currentLang];
                        } else {
                            element.textContent = element.dataset[this.currentLang];
                        }
                    }
                });
            }
            
            getText(ukText, enText) {
                return this.currentLang === 'uk' ? ukText : enText;
            }
        }

        // ============================================
        // SOUND GENERATOR
        // ============================================
        class SoundGenerator {
            constructor() {
                this.audioContext = null;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log("Web Audio API не підтримується");
                }
            }
            
            playTone(frequency, duration, type = 'sine', volume = 0.15) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            playPlaceX() {
                this.playTone(523.25, 0.1, 'square');
            }
            
            playPlaceO() {
                this.playTone(392.00, 0.1, 'triangle');
            }
            
            playWinLocal() {
                this.playTone(659.25, 0.15, 'square');
            }
            
            playWinGlobal() {
                this.playTone(523.25, 0.1, 'square');
                setTimeout(() => this.playTone(659.25, 0.1, 'square'), 100);
                setTimeout(() => this.playTone(783.99, 0.2, 'square'), 200);
            }
            
            playAIMove() {
                this.playTone(349.23, 0.1, 'sawtooth');
            }

            playAIThinking() {
                this.playTone(261.63, 0.05, 'sine', 0.1);
                setTimeout(() => this.playTone(293.66, 0.05, 'sine', 0.1), 50);
                setTimeout(() => this.playTone(329.63, 0.05, 'sine', 0.1), 100);
            }
        }

        // ============================================
        // ULTIMATE TIC-TAC-TOE GAME WITH MCTS AI
        // ============================================
        class UltimateTicTacToe {
            constructor() {
                this.localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
                this.localBoardsStatus = Array(9).fill('');
                this.globalBoard = Array(9).fill('');
                
                this.currentPlayer = 'X';
                this.activeBoard = null;
                this.gameOver = false;
                this.scores = { X: 0, O: 0 };
                
                this.gameMode = 'twoPlayers';
                this.aiDifficulty = 'medium';
                this.aiThinking = false;
                
                this.languageManager = new LanguageManager();
                this.sound = new SoundGenerator();
                this.mctsAI = new MCTSPlayer(this.aiDifficulty);
                
                this.init();
            }
            
            init() {
                this.drawBoard();
                this.setupEventListeners();
                this.updateStatus();
                this.loadScores();
            }
            
            drawBoard() {
                const megaBoard = document.getElementById('megaBoard');
                megaBoard.innerHTML = '';
                
                for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                    const localBoard = document.createElement('div');
                    localBoard.className = 'local-board';
                    localBoard.dataset.boardIndex = boardIndex;
                    
                    const status = this.localBoardsStatus[boardIndex];
                    if (status === 'X') {
                        localBoard.classList.add('won', 'won-x');
                        localBoard.dataset.winner = 'X';
                    } else if (status === 'O') {
                        localBoard.classList.add('won', 'won-o');
                        localBoard.dataset.winner = 'O';
                    } else if (status === 'tie') {
                        localBoard.classList.add('tied');
                    }
                    
                    if (this.activeBoard === null || this.activeBoard === boardIndex) {
                        if (status === '' && !this.gameOver) {
                            localBoard.classList.add('active');
                        }
                    }
                    
                    for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.boardIndex = boardIndex;
                        cell.dataset.cellIndex = cellIndex;
                        
                        const cellValue = this.localBoards[boardIndex][cellIndex];
                        if (cellValue) {
                            cell.textContent = cellValue;
                            cell.classList.add(cellValue.toLowerCase());
                        }
                        
                        const isActiveBoard = this.activeBoard === null || this.activeBoard === boardIndex;
                        const isBoardAvailable = status === '';
                        
                        if (!isActiveBoard || !isBoardAvailable || cellValue || this.gameOver) {
                            cell.classList.add('disabled');
                        }
                        
                        if (this.gameMode === 'vsAI' && this.currentPlayer === 'O' && !this.gameOver) {
                            cell.classList.add('disabled');
                        }
                        
                        cell.addEventListener('click', () => this.handleCellClick(boardIndex, cellIndex));
                        localBoard.appendChild(cell);
                    }
                    
                    megaBoard.appendChild(localBoard);
                }
            }
            
            handleCellClick(boardIndex, cellIndex) {
                if (this.gameOver) return;
                if (this.localBoards[boardIndex][cellIndex] !== '') return;
                if (this.localBoardsStatus[boardIndex] !== '') return;
                if (this.activeBoard !== null && this.activeBoard !== boardIndex) return;
                
                if (this.gameMode === 'vsAI' && this.currentPlayer === 'O') return;
                
                this.makeMove(boardIndex, cellIndex);
            }
            
            makeMove(boardIndex, cellIndex) {
                this.localBoards[boardIndex][cellIndex] = this.currentPlayer;
                
                this.currentPlayer === 'X' ? this.sound.playPlaceX() : this.sound.playPlaceO();
                
                if (navigator.vibrate) navigator.vibrate(10);
                
                const localWinner = this.checkLocalBoardWinner(boardIndex);
                if (localWinner) {
                    this.localBoardsStatus[boardIndex] = localWinner;
                    this.globalBoard[boardIndex] = localWinner;
                    this.sound.playWinLocal();
                    
                    const globalWinner = this.checkGlobalWinner();
                    if (globalWinner) {
                        this.handleGameWin(globalWinner);
                        this.drawBoard();
                        return;
                    }
                } else if (this.isLocalBoardFull(boardIndex)) {
                    this.localBoardsStatus[boardIndex] = 'tie';
                }
                
                const nextBoard = cellIndex;
                if (this.localBoardsStatus[nextBoard] === '') {
                    this.activeBoard = nextBoard;
                } else {
                    this.activeBoard = null;
                }
                
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                
                this.drawBoard();
                this.updateStatus();
                
                if (this.gameMode === 'vsAI' && this.currentPlayer === 'O' && !this.gameOver) {
                    this.makeAIMove();
                }
            }

            createMCTSState() {
                return new MCTSGameState(
                    this.localBoards,
                    this.localBoardsStatus,
                    this.currentPlayer,
                    this.activeBoard
                );
            }
            
            makeAIMove() {
                if (this.aiThinking) return;
                this.aiThinking = true;

                const statusElement = document.getElementById('status');
                const playerIcon = document.querySelector('.player-icon');
                const progressBar = document.getElementById('aiProgress');
                const progressBarInner = document.getElementById('aiProgressBar');
                const progressText = document.getElementById('progressText');

                statusElement.textContent = this.languageManager.getText(
                    '🤖 AI аналізує позицію...',
                    '🤖 AI analyzing position...'
                );
                statusElement.classList.add('ai-thinking');
                progressBar.style.display = 'block';

                playerIcon.classList.add('ai-thinking');
                playerIcon.textContent = '🤖';

                this.sound.playAIThinking();

                const gameState = this.createMCTSState();
                
                const progressCallback = (progress, iterations) => {
                    progressBarInner.style.width = `${progress}%`;
                    progressText.textContent = this.languageManager.getText(
                        `AI аналізує... ${iterations} ітерацій`,
                        `AI analyzing... ${iterations} iterations`
                    );
                };

                setTimeout(() => {
                    try {
                        const aiMove = this.mctsAI.getMove(gameState, progressCallback);
                        
                        if (aiMove) {
                            this.sound.playAIMove();
                            this.makeMove(aiMove.boardIndex, aiMove.cellIndex);
                        } else {
                            const availableMoves = this.getAvailableMoves();
                            if (availableMoves.length > 0) {
                                const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                                this.makeMove(randomMove.boardIndex, randomMove.cellIndex);
                            }
                        }
                    } catch (error) {
                        console.error('AI move error:', error);
                        const availableMoves = this.getAvailableMoves();
                        if (availableMoves.length > 0) {
                            const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                            this.makeMove(randomMove.boardIndex, randomMove.cellIndex);
                        }
                    }

                    statusElement.classList.remove('ai-thinking');
                    playerIcon.classList.remove('ai-thinking');
                    progressBar.style.display = 'none';
                    this.aiThinking = false;
                }, 100);
            }

            getAvailableMoves() {
                const moves = [];
                const playableBoards = this.activeBoard === null ? 
                    this.localBoardsStatus.map((status, index) => status === '' ? index : -1).filter(i => i !== -1) :
                    [this.activeBoard];
                
                playableBoards.forEach(boardIndex => {
                    if (this.localBoardsStatus[boardIndex] === '') {
                        for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                            if (this.localBoards[boardIndex][cellIndex] === '') {
                                moves.push({ boardIndex, cellIndex });
                            }
                        }
                    }
                });
                return moves;
            }
            
            checkLocalBoardWinner(boardIndex) {
                const board = this.localBoards[boardIndex];
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                
                for (const [a, b, c] of patterns) {
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a];
                    }
                }
                return null;
            }
            
            isLocalBoardFull(boardIndex) {
                return this.localBoards[boardIndex].every(cell => cell !== '');
            }
            
            checkGlobalWinner() {
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                
                for (const [a, b, c] of patterns) {
                    if (this.globalBoard[a] && 
                        this.globalBoard[a] === this.globalBoard[b] && 
                        this.globalBoard[a] === this.globalBoard[c]) {
                        return this.globalBoard[a];
                    }
                }
                
                if (this.localBoardsStatus.every(status => status !== '')) {
                    return 'tie';
                }
                
                return null;
            }
            
            handleGameWin(winner) {
                this.gameOver = true;
                
                if (winner !== 'tie') {
                    this.scores[winner]++;
                    this.saveScores();
                    this.updateScores();
                    this.sound.playWinGlobal();
                    
                    if (navigator.vibrate) {
                        navigator.vibrate([100, 50, 100, 50, 200]);
                    }
                    
                    this.updateStatus(
                        this.languageManager.getText(
                            `🎉 Гравець ${winner} виграв гру!`,
                            `🎉 Player ${winner} wins!`
                        ),
                        true
                    );
                } else {
                    this.updateStatus(
                        this.languageManager.getText('🤝 Глобальна нічия!', '🤝 Game tied!'),
                        true
                    );
                }
            }
            
            updateStatus(message = null, isWin = false) {
                const statusElement = document.getElementById('status');
                const playerIcon = document.querySelector('.player-icon');
                const playerText = document.getElementById('currentPlayerText');
                
                if (message) {
                    statusElement.textContent = message;
                    if (isWin) {
                        statusElement.classList.add('win');
                    }
                    return;
                }
                
                statusElement.classList.remove('win', 'ai-thinking');
                playerIcon.className = 'player-icon';
                playerIcon.classList.add(this.currentPlayer === 'X' ? 'player-x' : 'player-o');
                playerIcon.textContent = this.currentPlayer;
                
                playerText.textContent = this.languageManager.getText(
                    `Гравець ${this.currentPlayer}`,
                    `Player ${this.currentPlayer}`
                );
                
                if (this.activeBoard === null) {
                    statusElement.textContent = this.languageManager.getText(
                        `Гравець ${this.currentPlayer} може зробити хід в будь-якій дошці`,
                        `Player ${this.currentPlayer} can move in any board`
                    );
                } else {
                    const row = Math.floor(this.activeBoard / 3) + 1;
                    const col = (this.activeBoard % 3) + 1;
                    statusElement.textContent = this.languageManager.getText(
                        `Гравець ${this.currentPlayer} повинен грати в дошці ${row}×${col}`,
                        `Player ${this.currentPlayer} must play in board ${row}×${col}`
                    );
                }
            }
            
            updateScores() {
                document.getElementById('scoreX').textContent = this.scores.X;
                document.getElementById('scoreO').textContent = this.scores.O;
            }
            
            saveScores() {
                window.ultimateScores = this.scores;
            }
            
            loadScores() {
                if (window.ultimateScores) {
                    this.scores = window.ultimateScores;
                    this.updateScores();
                }
            }
            
            setGameMode(mode) {
                this.gameMode = mode;
                const difficultySelector = document.getElementById('difficultySelector');
                
                if (mode === 'vsAI') {
                    difficultySelector.style.display = 'flex';
                } else {
                    difficultySelector.style.display = 'none';
                }
                
                this.resetGame();
            }
            
            setAIDifficulty(difficulty) {
                this.aiDifficulty = difficulty;
                this.mctsAI.setDifficulty(difficulty);
            }
            
            resetGame() {
                this.localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
                this.localBoardsStatus = Array(9).fill('');
                this.globalBoard = Array(9).fill('');
                this.currentPlayer = 'X';
                this.activeBoard = null;
                this.gameOver = false;
                this.aiThinking = false;
                
                const progressBar = document.getElementById('aiProgress');
                progressBar.style.display = 'none';
                
                this.drawBoard();
                this.updateStatus();
            }
            
            setupEventListeners() {
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetGame();
                });
                
                document.getElementById('rulesBtn').addEventListener('click', () => {
                    this.showTutorial();
                });
                
                document.getElementById('tutorialBtn').addEventListener('click', () => {
                    this.showTutorial();
                });
                
                document.getElementById('closeModal').addEventListener('click', () => {
                    this.hideTutorial();
                });
                
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setGameMode(btn.dataset.mode);
                    });
                });
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setAIDifficulty(btn.dataset.diff);
                    });
                });
                
                document.getElementById('tutorialModal').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialModal') {
                        this.hideTutorial();
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideTutorial();
                    }
                });
            }
            
            showTutorial() {
                document.getElementById('tutorialModal').classList.add('active');
            }
            
            hideTutorial() {
                document.getElementById('tutorialModal').classList.remove('active');
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            const game = new UltimateTicTacToe();
            
            window.ultimateGame = game;
            
            console.log('%c🎮 ULTIMATE TIC-TAC-TOE', 'color: #0ff; font-size: 20px; font-weight: bold;');
            console.log('%c⚡ Cyberpunk Edition with Advanced MCTS AI', 'color: #f0f; font-size: 16px;');
            console.log('%cGame object available as window.ultimateGame', 'color: #0f0; font-size: 12px;');
        });
    </script>
</body>
</html>
