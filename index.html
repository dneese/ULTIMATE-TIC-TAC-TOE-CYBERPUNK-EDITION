<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe - –ö—ñ–±–µ—Ä–ø–∞–Ω–∫</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --neon-cyan: #0ff;
            --neon-pink: #f0f;
            --neon-purple: #906cff;
            --neon-green: #0f0;
            --neon-yellow: #ff0;
            --dark-bg: #0a0a16;
            --darker-bg: #050510;
            --grid-color: #1a1a2e;
        }

        body {
            background: var(--darker-bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            color: white;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        /* Scanlines effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.03) 0px,
                transparent 1px,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 3px
            );
            pointer-events: none;
            z-index: 1;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }

        .container {
            width: 100%;
            max-width: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px var(--neon-cyan);
            margin-bottom: 5px;
            letter-spacing: 3px;
            animation: glitchTitle 3s infinite;
        }

        @keyframes glitchTitle {
            0%, 90%, 100% { transform: translate(0); }
            91% { transform: translate(-2px, 2px); }
            93% { transform: translate(2px, -2px); }
            95% { transform: translate(0); }
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            letter-spacing: 2px;
        }

        /* Language selector */
        .language-selector {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 8px;
        }

        .lang-btn {
            background: rgba(20, 20, 40, 0.7);
            border: 1px solid var(--neon-purple);
            color: var(--neon-cyan);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.3s ease;
        }

        .lang-btn.active {
            background: rgba(144, 108, 255, 0.5);
            box-shadow: 0 0 10px var(--neon-purple);
        }

        .lang-btn:hover {
            background: rgba(144, 108, 255, 0.3);
        }

        /* Game mode selector */
        .game-mode-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 10px 20px;
            background: rgba(20, 20, 40, 0.7);
            border: 2px solid var(--neon-purple);
            border-radius: 6px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 140px;
            text-align: center;
        }

        .mode-btn.active {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        .mode-btn:hover {
            background: rgba(144, 108, 255, 0.2);
            transform: translateY(-2px);
        }

        /* AI Progress */
        .ai-progress {
            width: 100%;
            height: 4px;
            background: rgba(20, 20, 40, 0.8);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }

        .ai-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 0.7rem;
            text-align: center;
            margin-top: 5px;
            color: var(--neon-cyan);
        }

        /* Tutorial button */
        .tutorial-btn {
            padding: 8px 16px;
            background: rgba(144, 108, 255, 0.3);
            border: 1px solid var(--neon-purple);
            border-radius: 6px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .tutorial-btn:hover {
            background: rgba(144, 108, 255, 0.5);
            box-shadow: 0 0 15px var(--neon-purple);
        }

        /* Game info panel */
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            gap: 15px;
            margin-bottom: 15px;
        }

        .info-panel {
            flex: 1;
            padding: 15px;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 8px;
            border: 1px solid var(--neon-purple);
            box-shadow: 0 0 10px rgba(144, 108, 255, 0.3);
            text-align: center;
        }

        .player-turn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .player-icon {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .player-x {
            background: var(--neon-cyan);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        .player-o {
            background: var(--neon-pink);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .ai-thinking {
            background: var(--neon-yellow);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-yellow);
            animation: aiPulse 1s infinite;
        }

        @keyframes aiPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        .score-display {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .score-item {
            text-align: center;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }

        .score-label {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        /* Main game board */
        .mega-board {
            width: 100%;
            max-width: 650px;
            aspect-ratio: 1/1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            background: var(--darker-bg);
            padding: 15px;
            border-radius: 12px;
            border: 3px solid var(--neon-purple);
            box-shadow: 
                0 0 30px rgba(144, 108, 255, 0.5),
                inset 0 0 30px rgba(0, 0, 0, 0.6);
        }

        /* Local board (each small 3x3) */
        .local-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            background: var(--grid-color);
            padding: 6px;
            border-radius: 8px;
            border: 2px solid rgba(144, 108, 255, 0.4);
            position: relative;
            transition: all 0.3s ease;
        }

        .local-board.active {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 25px var(--neon-yellow), inset 0 0 15px rgba(255, 255, 0, 0.2);
            animation: activeBoardPulse 1.5s infinite;
        }

        @keyframes activeBoardPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .local-board.won {
            pointer-events: none;
        }

        .local-board.won::before {
            content: attr(data-winner);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: 900;
            opacity: 0.3;
            z-index: 10;
            animation: wonAppear 0.5s ease-out;
        }

        .local-board.won-x::before {
            color: var(--neon-cyan);
            text-shadow: 0 0 30px var(--neon-cyan);
        }

        .local-board.won-o::before {
            color: var(--neon-pink);
            text-shadow: 0 0 30px var(--neon-pink);
        }

        @keyframes wonAppear {
            from { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.3; }
        }

        .local-board.won-x {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-cyan);
        }

        .local-board.won-o {
            background: rgba(255, 0, 255, 0.1);
            border-color: var(--neon-pink);
        }

        .local-board.tied {
            background: rgba(128, 128, 128, 0.2);
            border-color: #666;
            pointer-events: none;
        }

        .local-board.tied::before {
            content: '‚Äî';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10rem;
            font-weight: 900;
            color: #666;
            opacity: 0.3;
            z-index: 10;
        }

        /* Individual cells */
        .cell {
            background: rgba(20, 20, 40, 0.9);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(144, 108, 255, 0.3);
            position: relative;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .cell:hover:not(.x):not(.o)::before {
            width: 100%;
            height: 100%;
        }

        .cell:hover:not(.x):not(.o) {
            transform: scale(1.1);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        .cell.x, .cell.o {
            animation: cellAppear 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: default;
        }

        @keyframes cellAppear {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .cell.x {
            color: var(--neon-cyan);
            text-shadow: 0 0 15px var(--neon-cyan);
        }

        .cell.o {
            color: var(--neon-pink);
            text-shadow: 0 0 15px var(--neon-pink);
        }

        .cell.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Status message */
        .status-message {
            font-size: 1.1rem;
            font-weight: 700;
            text-align: center;
            min-height: 40px;
            padding: 12px 24px;
            border-radius: 8px;
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid var(--neon-purple);
            box-shadow: 0 0 20px rgba(144, 108, 255, 0.4);
            width: 100%;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            transition: all 0.3s ease;
        }

        .status-message.win {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
            color: var(--neon-green);
            animation: statusGlitch 2s infinite;
            font-size: 1.3rem;
        }

        .status-message.ai-thinking {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 20px var(--neon-yellow);
            color: var(--neon-yellow);
            animation: thinkingPulse 1.5s infinite;
        }

        @keyframes thinkingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes statusGlitch {
            0%, 94%, 100% { transform: translate(0); }
            95% { transform: translate(-3px, 3px); }
            97% { transform: translate(3px, -3px); }
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            flex-wrap: wrap;
        }

        .cyber-button {
            flex: 1;
            min-width: 140px;
            padding: 14px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .cyber-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .cyber-button:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-purple), #6a00ff);
            color: white;
            box-shadow: 0 0 20px rgba(144, 108, 255, 0.5);
            border: 2px solid var(--neon-cyan);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 25px rgba(144, 108, 255, 0.8);
        }

        .btn-secondary {
            background: rgba(20, 20, 40, 0.8);
            color: var(--neon-cyan);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        /* Difficulty selector */
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .diff-btn {
            padding: 8px 16px;
            background: rgba(20, 20, 40, 0.5);
            border: 1px solid var(--neon-purple);
            border-radius: 4px;
            color: var(--neon-cyan);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }

        .diff-btn.active {
            background: rgba(144, 108, 255, 0.3);
            border-color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        .diff-btn:hover {
            background: rgba(144, 108, 255, 0.2);
        }

        /* Tutorial modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--dark-bg);
            border: 2px solid var(--neon-purple);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(144, 108, 255, 0.6);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-header {
            font-size: 1.8rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-body {
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
        }

        .modal-body h3 {
            color: var(--neon-pink);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-body ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .modal-body li {
            margin-bottom: 8px;
        }

        .modal-close {
            margin-top: 20px;
            width: 100%;
        }

        .highlight {
            color: var(--neon-yellow);
            font-weight: bold;
        }

        /* Responsive */
        @media (max-width: 700px) {
            h1 { font-size: 1.8rem; }
            .subtitle { font-size: 0.75rem; }
            .mega-board { gap: 10px; padding: 10px; }
            .local-board { gap: 3px; padding: 4px; }
            .cell { font-size: 1.4rem; }
            .local-board.won::before { font-size: 5rem; }
            .game-info { flex-direction: column; }
            .language-selector { position: static; margin-bottom: 10px; }
            .game-mode-selector { flex-direction: column; }
            .mode-btn { min-width: 100%; }
        }

        @media (max-width: 480px) {
            .mega-board { gap: 8px; padding: 8px; max-width: 100%; }
            .local-board { gap: 2px; padding: 3px; }
            .cell { font-size: 1.2rem; }
            .local-board.won::before { font-size: 4rem; }
            .controls { flex-direction: column; }
            .cyber-button { min-width: 100%; }
            .difficulty-selector { flex-direction: column; }
            .diff-btn { min-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="language-selector">
                <button class="lang-btn active" data-lang="uk">UA</button>
                <button class="lang-btn" data-lang="en">EN</button>
            </div>
            <h1 data-uk="ULTIMATE TIC-TAC-TOE" data-en="ULTIMATE TIC-TAC-TOE">ULTIMATE TIC-TAC-TOE</h1>
            <div class="subtitle" data-uk="–ö–Ü–ë–ï–†–ü–ê–ù–ö –í–ï–†–°–Ü–Ø" data-en="CYBERPUNK EDITION">–ö–Ü–ë–ï–†–ü–ê–ù–ö –í–ï–†–°–Ü–Ø</div>
            
            <!-- Game Mode Selector -->
            <div class="game-mode-selector">
                <button class="mode-btn active" data-mode="twoPlayers" data-uk="üë• –î–≤–∞ –≥—Ä–∞–≤—Ü—ñ" data-en="üë• Two Players">üë• –î–≤–∞ –≥—Ä–∞–≤—Ü—ñ</button>
                <button class="mode-btn" data-mode="vsAI" data-uk="ü§ñ –ì—Ä–∞ –∑ AI" data-en="ü§ñ VS AI">ü§ñ –ì—Ä–∞ –∑ AI</button>
            </div>

            <!-- Difficulty Selector (visible only in AI mode) -->
            <div class="difficulty-selector" id="difficultySelector" style="display: none;">
                <button class="diff-btn active" data-diff="easy" data-uk="üòä –õ–µ–≥–∫–∏–π" data-en="üòä Easy">üòä –õ–µ–≥–∫–∏–π</button>
                <button class="diff-btn" data-diff="medium" data-uk="üòê –°–µ—Ä–µ–¥–Ω—ñ–π" data-en="üòê Medium">üòê –°–µ—Ä–µ–¥–Ω—ñ–π</button>
                <button class="diff-btn" data-diff="hard" data-uk="üòà –°–∫–ª–∞–¥–Ω–∏–π" data-en="üòà Hard">üòà –°–∫–ª–∞–¥–Ω–∏–π</button>
                <button class="diff-btn" data-diff="expert" data-uk="üß† –ï–∫—Å–ø–µ—Ä—Ç" data-en="üß† Expert">üß† –ï–∫—Å–ø–µ—Ä—Ç</button>
                <button class="diff-btn" data-diff="master" data-uk="üèÜ –ú–∞–π—Å—Ç–µ—Ä" data-en="üèÜ Master">üèÜ –ú–∞–π—Å—Ç–µ—Ä</button>
            </div>

            <!-- AI Progress -->
            <div class="ai-progress" id="aiProgress">
                <div class="ai-progress-bar" id="aiProgressBar"></div>
                <div class="progress-text" id="progressText">AI –∞–Ω–∞–ª—ñ–∑—É—î...</div>
            </div>

            <button class="tutorial-btn" id="tutorialBtn" data-uk="üìñ –Ø–∫ –≥—Ä–∞—Ç–∏?" data-en="üìñ How to play?">üìñ –Ø–∫ –≥—Ä–∞—Ç–∏?</button>
        </div>

        <!-- Game Info -->
        <div class="game-info">
            <div class="info-panel">
                <div class="player-turn">
                    <div class="player-icon player-x">X</div>
                    <div>
                        <div style="font-size: 0.9rem; opacity: 0.8;" data-uk="–ó–∞—Ä–∞–∑ –≥—Ä–∞—î" data-en="Current player">–ó–∞—Ä–∞–∑ –≥—Ä–∞—î</div>
                        <div id="currentPlayerText" style="font-size: 1.2rem; font-weight: bold;" data-uk="–ì—Ä–∞–≤–µ—Ü—å X" data-en="Player X">–ì—Ä–∞–≤–µ—Ü—å X</div>
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <div style="font-size: 0.8rem; opacity: 0.8; margin-bottom: 8px;" data-uk="–†–ê–•–£–ù–û–ö" data-en="SCORE">–†–ê–•–£–ù–û–ö</div>
                <div class="score-display">
                    <div class="score-item">
                        <div class="score-value" id="scoreX">0</div>
                        <div class="score-label">X</div>
                    </div>
                    <div class="score-item">
                        <div class="score-value" id="scoreO">0</div>
                        <div class="score-label">O</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Message -->
        <div class="status-message" id="status" data-uk="–ì—Ä–∞–≤–µ—Ü—å X –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –¥–æ—à—Ü—ñ" data-en="Player X can move in any board">
            –ì—Ä–∞–≤–µ—Ü—å X –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –¥–æ—à—Ü—ñ
        </div>

        <!-- Main Game Board -->
        <div class="mega-board" id="megaBoard"></div>

        <!-- Controls -->
        <div class="controls">
            <button class="cyber-button btn-primary" id="resetBtn">
                <span data-uk="üîÑ –ù–æ–≤–∞ –≥—Ä–∞" data-en="üîÑ New Game">üîÑ –ù–æ–≤–∞ –≥—Ä–∞</span>
            </button>
            <button class="cyber-button btn-secondary" id="rulesBtn">
                <span data-uk="üìú –ü—Ä–∞–≤–∏–ª–∞" data-en="üìú Rules">üìú –ü—Ä–∞–≤–∏–ª–∞</span>
            </button>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal" id="tutorialModal">
        <div class="modal-content">
            <div class="modal-header" data-uk="üéÆ –Ø–∫ –≥—Ä–∞—Ç–∏ –≤ Ultimate Tic-Tac-Toe" data-en="üéÆ How to play Ultimate Tic-Tac-Toe">
                üéÆ –Ø–∫ –≥—Ä–∞—Ç–∏ –≤ Ultimate Tic-Tac-Toe
            </div>
            <div class="modal-body">
                <h3 data-uk="üéØ –ú–µ—Ç–∞ –≥—Ä–∏" data-en="üéØ Game Objective">üéØ –ú–µ—Ç–∞ –≥—Ä–∏</h3>
                <p data-uk="–í–∏–≥—Ä–∞—Ç–∏ —Ç—Ä–∏ –º–∞–ª—ñ –¥–æ—à–∫–∏ –ø–æ—Å–ø—ñ–ª—å (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ –∞–±–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ) –Ω–∞ –≤–µ–ª–∏–∫—ñ–π –¥–æ—à—Ü—ñ 3√ó3." data-en="Win three small boards in a row (horizontally, vertically or diagonally) on the large 3√ó3 board.">
                    –í–∏–≥—Ä–∞—Ç–∏ <span class="highlight">—Ç—Ä–∏ –º–∞–ª—ñ –¥–æ—à–∫–∏ –ø–æ—Å–ø—ñ–ª—å</span> (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ –∞–±–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—å–Ω–æ) –Ω–∞ –≤–µ–ª–∏–∫—ñ–π –¥–æ—à—Ü—ñ 3√ó3.
                </p>

                <h3 data-uk="üìã –ü—Ä–∞–≤–∏–ª–∞" data-en="üìã Rules">üìã –ü—Ä–∞–≤–∏–ª–∞</h3>
                <ul>
                    <li data-uk="–ü–µ—Ä—à–∏–π —Ö—ñ–¥: –ì—Ä–∞–≤–µ—Ü—å X –ø–æ—á–∏–Ω–∞—î —ñ –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ –±—É–¥—å-—è–∫–æ—ó –º–∞–ª–æ—ó –¥–æ—à–∫–∏." data-en="First move: Player X starts and can move in any cell of any small board.">
                        <strong data-uk="–ü–µ—Ä—à–∏–π —Ö—ñ–¥:" data-en="First move:">–ü–µ—Ä—à–∏–π —Ö—ñ–¥:</strong> <span data-uk="–ì—Ä–∞–≤–µ—Ü—å X –ø–æ—á–∏–Ω–∞—î —ñ –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ –±—É–¥—å-—è–∫–æ—ó –º–∞–ª–æ—ó –¥–æ—à–∫–∏." data-en="Player X starts and can move in any cell of any small board.">–ì—Ä–∞–≤–µ—Ü—å X –ø–æ—á–∏–Ω–∞—î —ñ –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ –±—É–¥—å-—è–∫–æ—ó –º–∞–ª–æ—ó –¥–æ—à–∫–∏.</span>
                    </li>
                    
                    <li data-uk="–ù–∞—Å—Ç—É–ø–Ω—ñ —Ö–æ–¥–∏: –ü–æ–∑–∏—Ü—ñ—è –≤–∞—à–æ–≥–æ —Ö–æ–¥—É –≤–∏–∑–Ω–∞—á–∞—î, –≤ —è–∫—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ –º–∞—î —Ö–æ–¥–∏—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å." data-en="Next moves: Your move position determines in which small board the next player must play.">
                        <strong data-uk="–ù–∞—Å—Ç—É–ø–Ω—ñ —Ö–æ–¥–∏:" data-en="Next moves:">–ù–∞—Å—Ç—É–ø–Ω—ñ —Ö–æ–¥–∏:</strong> <span data-uk="–ü–æ–∑–∏—Ü—ñ—è –≤–∞—à–æ–≥–æ —Ö–æ–¥—É –≤–∏–∑–Ω–∞—á–∞—î, –≤ —è–∫—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ –º–∞—î —Ö–æ–¥–∏—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å." data-en="Your move position determines in which small board the next player must play.">–ü–æ–∑–∏—Ü—ñ—è –≤–∞—à–æ–≥–æ —Ö–æ–¥—É –≤–∏–∑–Ω–∞—á–∞—î, <span class="highlight">–≤ —è–∫—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ –º–∞—î —Ö–æ–¥–∏—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å</span>.</span>
                    </li>
                    
                    <li data-uk="–ü—Ä–∏–∫–ª–∞–¥: –Ø–∫—â–æ –≤–∏ –∑—Ä–æ–±–∏–ª–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—å–æ–º—É –ø—Ä–∞–≤–æ–º—É –∫—É—Ç–∫—É –º–∞–ª–æ—ó –¥–æ—à–∫–∏, –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å –ü–û–í–ò–ù–ï–ù –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—ñ–π –ø—Ä–∞–≤—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ." data-en="Example: If you move in the top-right corner of a small board, the next player MUST play in the top-right small board.">
                        <strong data-uk="–ü—Ä–∏–∫–ª–∞–¥:" data-en="Example:">–ü—Ä–∏–∫–ª–∞–¥:</strong> <span data-uk="–Ø–∫—â–æ –≤–∏ –∑—Ä–æ–±–∏–ª–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—å–æ–º—É –ø—Ä–∞–≤–æ–º—É –∫—É—Ç–∫—É –º–∞–ª–æ—ó –¥–æ—à–∫–∏, –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å –ü–û–í–ò–ù–ï–ù –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—ñ–π –ø—Ä–∞–≤—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ." data-en="If you move in the top-right corner of a small board, the next player MUST play in the top-right small board.">–Ø–∫—â–æ –≤–∏ –∑—Ä–æ–±–∏–ª–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—å–æ–º—É –ø—Ä–∞–≤–æ–º—É –∫—É—Ç–∫—É –º–∞–ª–æ—ó –¥–æ—à–∫–∏, –Ω–∞—Å—Ç—É–ø–Ω–∏–π –≥—Ä–∞–≤–µ—Ü—å –ü–û–í–ò–ù–ï–ù –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ —É –≤–µ—Ä—Ö–Ω—ñ–π –ø—Ä–∞–≤—ñ–π –º–∞–ª—ñ–π –¥–æ—à—Ü—ñ.</span>
                    </li>
                    
                    <li data-uk="–í–∏–≥—Ä–∞—à –º–∞–ª–æ—ó –¥–æ—à–∫–∏: –í–∏–≥—Ä–∞–π—Ç–µ –º–∞–ª—É –¥–æ—à–∫—É, –ø–æ—Å—Ç–∞–≤–∏–≤—à–∏ —Ç—Ä–∏ —Å–≤–æ—ó —Å–∏–º–≤–æ–ª–∏ –ø–æ—Å–ø—ñ–ª—å (—è–∫ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö —Ö—Ä–µ—Å—Ç–∏–∫–∞—Ö-–Ω–æ–ª–∏–∫–∞—Ö)." data-en="Winning a small board: Win a small board by placing three of your symbols in a row (like regular tic-tac-toe).">
                        <strong data-uk="–í–∏–≥—Ä–∞—à –º–∞–ª–æ—ó –¥–æ—à–∫–∏:" data-en="Winning a small board:">–í–∏–≥—Ä–∞—à –º–∞–ª–æ—ó –¥–æ—à–∫–∏:</strong> <span data-uk="–í–∏–≥—Ä–∞–π—Ç–µ –º–∞–ª—É –¥–æ—à–∫—É, –ø–æ—Å—Ç–∞–≤–∏–≤—à–∏ —Ç—Ä–∏ —Å–≤–æ—ó —Å–∏–º–≤–æ–ª–∏ –ø–æ—Å–ø—ñ–ª—å (—è–∫ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö —Ö—Ä–µ—Å—Ç–∏–∫–∞—Ö-–Ω–æ–ª–∏–∫–∞—Ö)." data-en="Win a small board by placing three of your symbols in a row (like regular tic-tac-toe).">–í–∏–≥—Ä–∞–π—Ç–µ –º–∞–ª—É –¥–æ—à–∫—É, –ø–æ—Å—Ç–∞–≤–∏–≤—à–∏ —Ç—Ä–∏ —Å–≤–æ—ó —Å–∏–º–≤–æ–ª–∏ –ø–æ—Å–ø—ñ–ª—å (—è–∫ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö —Ö—Ä–µ—Å—Ç–∏–∫–∞—Ö-–Ω–æ–ª–∏–∫–∞—Ö).</span>
                    </li>
                    
                    <li data-uk="–ó–∞–ø–æ–≤–Ω–µ–Ω–∞ –¥–æ—à–∫–∞: –Ø–∫—â–æ –≤–∞—Å –≤—ñ–¥–ø—Ä–∞–≤–ª—è—é—Ç—å –Ω–∞ –≤–∂–µ –≤–∏–≥—Ä–∞–Ω—É –∞–±–æ –Ω—ñ—á–∏–π–Ω—É –¥–æ—à–∫—É, –≤–∏ –º–æ–∂–µ—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –Ω–∞ –±—É–¥—å-—è–∫—ñ–π –¥–æ—Å—Ç—É–ø–Ω—ñ–π –¥–æ—à—Ü—ñ." data-en="Full board: If you're sent to an already won or tied board, you can move in any available board.">
                        <strong data-uk="–ó–∞–ø–æ–≤–Ω–µ–Ω–∞ –¥–æ—à–∫–∞:" data-en="Full board:">–ó–∞–ø–æ–≤–Ω–µ–Ω–∞ –¥–æ—à–∫–∞:</strong> <span data-uk="–Ø–∫—â–æ –≤–∞—Å –≤—ñ–¥–ø—Ä–∞–≤–ª—è—é—Ç—å –Ω–∞ –≤–∂–µ –≤–∏–≥—Ä–∞–Ω—É –∞–±–æ –Ω—ñ—á–∏–π–Ω—É –¥–æ—à–∫—É, –≤–∏ –º–æ–∂–µ—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –Ω–∞ –±—É–¥—å-—è–∫—ñ–π –¥–æ—Å—Ç—É–ø–Ω—ñ–π –¥–æ—à—Ü—ñ." data-en="If you're sent to an already won or tied board, you can move in any available board.">–Ø–∫—â–æ –≤–∞—Å –≤—ñ–¥–ø—Ä–∞–≤–ª—è—é—Ç—å –Ω–∞ –≤–∂–µ –≤–∏–≥—Ä–∞–Ω—É –∞–±–æ –Ω—ñ—á–∏–π–Ω—É –¥–æ—à–∫—É, –≤–∏ –º–æ–∂–µ—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –Ω–∞ –±—É–¥—å-—è–∫—ñ–π –¥–æ—Å—Ç—É–ø–Ω—ñ–π –¥–æ—à—Ü—ñ.</span>
                    </li>
                    
                    <li data-uk="–ù—ñ—á–∏—è: –Ø–∫—â–æ –º–∞–ª–∞ –¥–æ—à–∫–∞ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞ –±–µ–∑ –ø–µ—Ä–µ–º–æ–∂—Ü—è, –≤–æ–Ω–∞ –≤–≤–∞–∂–∞—î—Ç—å—Å—è –Ω—ñ—á–∏—î—é (—Å—ñ—Ä–æ—é)." data-en="Tie: If a small board is filled without a winner, it's considered a tie (gray).">
                        <strong data-uk="–ù—ñ—á–∏—è:" data-en="Tie:">–ù—ñ—á–∏—è:</strong> <span data-uk="–Ø–∫—â–æ –º–∞–ª–∞ –¥–æ—à–∫–∞ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞ –±–µ–∑ –ø–µ—Ä–µ–º–æ–∂—Ü—è, –≤–æ–Ω–∞ –≤–≤–∞–∂–∞—î—Ç—å—Å—è –Ω—ñ—á–∏—î—é (—Å—ñ—Ä–æ—é)." data-en="If a small board is filled without a winner, it's considered a tie (gray).">–Ø–∫—â–æ –º–∞–ª–∞ –¥–æ—à–∫–∞ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞ –±–µ–∑ –ø–µ—Ä–µ–º–æ–∂—Ü—è, –≤–æ–Ω–∞ –≤–≤–∞–∂–∞—î—Ç—å—Å—è –Ω—ñ—á–∏—î—é (—Å—ñ—Ä–æ—é).</span>
                    </li>
                </ul>

                <h3 data-uk="üéÆ –†–µ–∂–∏–º–∏ –≥—Ä–∏" data-en="üéÆ Game Modes">üéÆ –†–µ–∂–∏–º–∏ –≥—Ä–∏</h3>
                <ul>
                    <li data-uk="üë• –î–≤–∞ –≥—Ä–∞–≤—Ü—ñ: –ö–ª–∞—Å–∏—á–Ω–∏–π —Ä–µ–∂–∏–º –¥–ª—è –≥—Ä–∏ –∑ –¥—Ä—É–≥–æ–º" data-en="üë• Two Players: Classic mode to play with a friend">üë• <strong>–î–≤–∞ –≥—Ä–∞–≤—Ü—ñ:</strong> –ö–ª–∞—Å–∏—á–Ω–∏–π —Ä–µ–∂–∏–º –¥–ª—è –≥—Ä–∏ –∑ –¥—Ä—É–≥–æ–º</li>
                    <li data-uk="ü§ñ –ì—Ä–∞ –∑ AI: –ì—Ä–∞ –ø—Ä–æ—Ç–∏ —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É –∑ –ø'—è—Ç—å–º–∞ —Ä—ñ–≤–Ω—è–º–∏ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ" data-en="ü§ñ VS AI: Play against artificial intelligence with five difficulty levels">ü§ñ <strong>–ì—Ä–∞ –∑ AI:</strong> –ì—Ä–∞ –ø—Ä–æ—Ç–∏ —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É –∑ –ø'—è—Ç—å–º–∞ —Ä—ñ–≤–Ω—è–º–∏ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ</li>
                </ul>

                <h3 data-uk="üí° –ü—ñ–¥–∫–∞–∑–∫–∏" data-en="üí° Tips">üí° –ü—ñ–¥–∫–∞–∑–∫–∏</h3>
                <ul>
                    <li data-uk="–î—É–º–∞–π—Ç–µ –Ω–∞–ø–µ—Ä–µ–¥! –í–∞—à —Ö—ñ–¥ –≤–∏–∑–Ω–∞—á–∞—î, –¥–µ –≥—Ä–∞—Ç–∏–º–µ —Å—É–ø–µ—Ä–Ω–∏–∫." data-en="Think ahead! Your move determines where your opponent will play.">–î—É–º–∞–π—Ç–µ –Ω–∞–ø–µ—Ä–µ–¥! –í–∞—à —Ö—ñ–¥ –≤–∏–∑–Ω–∞—á–∞—î, –¥–µ –≥—Ä–∞—Ç–∏–º–µ —Å—É–ø–µ—Ä–Ω–∏–∫.</li>
                    <li data-uk="–ù–∞–º–∞–≥–∞–π—Ç–µ—Å—è –∫–æ–Ω—Ç—Ä–æ–ª—é–≤–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É –¥–æ—à–∫—É." data-en="Try to control the center board.">–ù–∞–º–∞–≥–∞–π—Ç–µ—Å—è –∫–æ–Ω—Ç—Ä–æ–ª—é–≤–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É –¥–æ—à–∫—É.</li>
                    <li data-uk="–ñ–æ–≤—Ç–∞ –ø—ñ–¥—Å–≤—ñ—Ç–∫–∞ –ø–æ–∫–∞–∑—É—î –∞–∫—Ç–∏–≤–Ω—É –¥–æ—à–∫—É." data-en="Yellow highlight shows the active board."><span class="highlight" data-uk="–ñ–æ–≤—Ç–∞ –ø—ñ–¥—Å–≤—ñ—Ç–∫–∞" data-en="Yellow highlight">–ñ–æ–≤—Ç–∞ –ø—ñ–¥—Å–≤—ñ—Ç–∫–∞</span> <span data-uk="–ø–æ–∫–∞–∑—É—î –∞–∫—Ç–∏–≤–Ω—É –¥–æ—à–∫—É." data-en="shows the active board.">–ø–æ–∫–∞–∑—É—î –∞–∫—Ç–∏–≤–Ω—É –¥–æ—à–∫—É.</span></li>
                    <li data-uk="–°—Ç—Ä–∞—Ç–µ–≥—ñ—è –Ω–∞–±–∞–≥–∞—Ç–æ –≤–∞–∂–ª–∏–≤—ñ—à–∞, –Ω—ñ–∂ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö —Ö—Ä–µ—Å—Ç–∏–∫–∞—Ö-–Ω–æ–ª–∏–∫–∞—Ö!" data-en="Strategy is much more important than in regular tic-tac-toe!">–°—Ç—Ä–∞—Ç–µ–≥—ñ—è –Ω–∞–±–∞–≥–∞—Ç–æ –≤–∞–∂–ª–∏–≤—ñ—à–∞, –Ω—ñ–∂ —É –∑–≤–∏—á–∞–π–Ω–∏—Ö —Ö—Ä–µ—Å—Ç–∏–∫–∞—Ö-–Ω–æ–ª–∏–∫–∞—Ö!</li>
                </ul>

                <h3 data-uk="üé® –õ–µ–≥–µ–Ω–¥–∞" data-en="üé® Legend">üé® –õ–µ–≥–µ–Ω–¥–∞</h3>
                <ul>
                    <li><span style="color: var(--neon-cyan);">üîµ <span data-uk="–ë–ª–∞–∫–∏—Ç–Ω–∏–π X" data-en="Blue X">–ë–ª–∞–∫–∏—Ç–Ω–∏–π X</span></span> ‚Äî <span data-uk="—Å–∏–º–≤–æ–ª –≥—Ä–∞–≤—Ü—è X" data-en="symbol of player X">—Å–∏–º–≤–æ–ª –≥—Ä–∞–≤—Ü—è X</span></li>
                    <li><span style="color: var(--neon-pink);">üî¥ <span data-uk="–†–æ–∂–µ–≤–∏–π O" data-en="Pink O">–†–æ–∂–µ–≤–∏–π O</span></span> ‚Äî <span data-uk="—Å–∏–º–≤–æ–ª –≥—Ä–∞–≤—Ü—è O" data-en="symbol of player O">—Å–∏–º–≤–æ–ª –≥—Ä–∞–≤—Ü—è O</span></li>
                    <li><span style="color: var(--neon-yellow);">üü° <span data-uk="–ñ–æ–≤—Ç–∞ —Ä–∞–º–∫–∞" data-en="Yellow border">–ñ–æ–≤—Ç–∞ —Ä–∞–º–∫–∞</span></span> ‚Äî <span data-uk="–∞–∫—Ç–∏–≤–Ω–∞ –¥–æ—à–∫–∞" data-en="active board">–∞–∫—Ç–∏–≤–Ω–∞ –¥–æ—à–∫–∞</span></li>
                    <li><span style="color: #666;">‚ö™ <span data-uk="–°—ñ—Ä–∞ –¥–æ—à–∫–∞" data-en="Gray board">–°—ñ—Ä–∞ –¥–æ—à–∫–∞</span></span> ‚Äî <span data-uk="–Ω—ñ—á–∏—è" data-en="tie">–Ω—ñ—á–∏—è</span></li>
                </ul>
            </div>
            <button class="cyber-button btn-primary modal-close" id="closeModal" data-uk="–ó—Ä–æ–∑—É–º—ñ–ª–æ, –ø–æ—á–∏–Ω–∞—î–º–æ!" data-en="Got it, let's start!">
                –ó—Ä–æ–∑—É–º—ñ–ª–æ, –ø–æ—á–∏–Ω–∞—î–º–æ!
            </button>
        </div>
    </div>

    <script>
        // ============================================
        // ADVANCED MCTS AI PLAYER
        // ============================================
        class MCTSNode {
            constructor(state, parent = null, move = null) {
                this.state = state;
                this.parent = parent;
                this.move = move;
                this.children = [];
                this.wins = 0;
                this.visits = 0;
                this.untriedMoves = state.getLegalMoves();
            }

            selectChild() {
                let bestChild = this.children[0];
                let bestValue = -Infinity;

                for (const child of this.children) {
                    if (child.visits === 0) {
                        return child;
                    }
                    
                    const exploitation = child.wins / child.visits;
                    const exploration = Math.sqrt(2 * Math.log(this.visits) / child.visits);
                    const ucbValue = exploitation + exploration;
                    
                    if (ucbValue > bestValue) {
                        bestValue = ucbValue;
                        bestChild = child;
                    }
                }
                
                return bestChild;
            }

            addChild(move, state) {
                const child = new MCTSNode(state, this, move);
                this.untriedMoves = this.untriedMoves.filter(m => 
                    !(m.boardIndex === move.boardIndex && m.cellIndex === move.cellIndex)
                );
                this.children.push(child);
                return child;
            }

            update(result) {
                this.visits++;
                this.wins += result;
            }
        }

        class MCTSPlayer {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.symbol = 'O';
                this.opponentSymbol = 'X';
                this.setDifficulty(difficulty);
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
                switch(difficulty) {
                    case 'easy':
                        this.iterations = 200;
                        this.timeLimit = 1000;
                        break;
                    case 'medium':
                        this.iterations = 800;
                        this.timeLimit = 2000;
                        break;
                    case 'hard':
                        this.iterations = 1500;
                        this.timeLimit = 3500;
                        break;
                    case 'expert':
                        this.iterations = 3000;
                        this.timeLimit = 5000;
                        break;
                    case 'master':
                        this.iterations = 100000;
                        this.timeLimit = 30000;
                        break;
                    default:
                        this.iterations = 800;
                        this.timeLimit = 2000;
                }
            }

            getMove(gameState, progressCallback = null) {
                const root = new MCTSNode(gameState);
                const startTime = Date.now();
                let iterations = 0;

                while (iterations < this.iterations && 
                       (Date.now() - startTime) < this.timeLimit) {
                    
                    let node = root;
                    let state = gameState.clone();

                    // Selection
                    while (node.untriedMoves.length === 0 && node.children.length > 0) {
                        node = node.selectChild();
                        state.makeMove(node.move);
                    }

                    // Expansion
                    if (node.untriedMoves.length > 0) {
                        const move = node.untriedMoves[
                            Math.floor(Math.random() * node.untriedMoves.length)
                        ];
                        state.makeMove(move);
                        node = node.addChild(move, state);
                    }

                    // Simulation
                    let simulationState = state.clone();
                    while (!simulationState.isTerminal()) {
                        const moves = simulationState.getLegalMoves();
                        if (moves.length === 0) break;
                        const randomMove = moves[Math.floor(Math.random() * moves.length)];
                        simulationState.makeMove(randomMove);
                    }

                    // Backpropagation
                    const result = this.getResult(simulationState);
                    while (node !== null) {
                        node.update(result);
                        node = node.parent;
                    }

                    iterations++;
                    
                    // Update progress
                    if (progressCallback && iterations % 50 === 0) {
                        const progress = Math.min(100, 
                            Math.max(
                                (iterations / this.iterations) * 100,
                                ((Date.now() - startTime) / this.timeLimit) * 100
                            )
                        );
                        progressCallback(progress, iterations);
                    }
                }

                // Select best move (most visited)
                let bestChild = root.children[0];
                for (const child of root.children) {
                    if (child.visits > bestChild.visits) {
                        bestChild = child;
                    }
                }

                console.log(`MCTS: ${iterations} iterations, best move visits: ${bestChild ? bestChild.visits : 0}`);
                return bestChild ? bestChild.move : null;
            }

            getResult(state) {
                const winner = state.getWinner();
                if (winner === this.symbol) return 1;
                if (winner === this.opponentSymbol) return 0;
                if (winner === 'tie') return 0.5;
                
                return 0.5; // Neutral for non-terminal states
            }
        }

        // ============================================
        // GAME STATE FOR MCTS
        // ============================================
        class MCTSGameState {
            constructor(localBoards, localBoardsStatus, currentPlayer, activeBoard) {
                this.localBoards = this.deepCopy(localBoards);
                this.localBoardsStatus = [...localBoardsStatus];
                this.currentPlayer = currentPlayer;
                this.activeBoard = activeBoard;
            }

            clone() {
                return new MCTSGameState(
                    this.localBoards,
                    this.localBoardsStatus,
                    this.currentPlayer,
                    this.activeBoard
                );
            }

            deepCopy(boards) {
                return boards.map(board => [...board]);
            }

            getLegalMoves() {
                const moves = [];
                
                const playableBoards = this.activeBoard === null ? 
                    this.localBoardsStatus.map((status, index) => status === '' ? index : -1).filter(i => i !== -1) :
                    [this.activeBoard];

                playableBoards.forEach(boardIndex => {
                    if (this.localBoardsStatus[boardIndex] === '') {
                        for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                            if (this.localBoards[boardIndex][cellIndex] === '') {
                                moves.push({ boardIndex, cellIndex });
                            }
                        }
                    }
                });

                return moves;
            }

            makeMove(move) {
                const { boardIndex, cellIndex } = move;
                
                this.localBoards[boardIndex][cellIndex] = this.currentPlayer;

                const localWinner = this.checkLocalBoardWinner(boardIndex);
                if (localWinner) {
                    this.localBoardsStatus[boardIndex] = localWinner;
                } else if (this.isLocalBoardFull(boardIndex)) {
                    this.localBoardsStatus[boardIndex] = 'tie';
                }

                this.activeBoard = this.localBoardsStatus[cellIndex] === '' ? cellIndex : null;
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
            }

            isTerminal() {
                return this.getWinner() !== null;
            }

            getWinner() {
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];

                for (const [a, b, c] of patterns) {
                    if (this.localBoardsStatus[a] && 
                        this.localBoardsStatus[a] === this.localBoardsStatus[b] && 
                        this.localBoardsStatus[a] === this.localBoardsStatus[c]) {
                        return this.localBoardsStatus[a];
                    }
                }

                if (this.localBoardsStatus.every(status => status !== '')) {
                    return 'tie';
                }

                return null;
            }

            checkLocalBoardWinner(boardIndex) {
                const board = this.localBoards[boardIndex];
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];

                for (const [a, b, c] of patterns) {
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a];
                    }
                }
                return null;
            }

            isLocalBoardFull(boardIndex) {
                return this.localBoards[boardIndex].every(cell => cell !== '');
            }
        }

        // ============================================
        // LANGUAGE MANAGER
        // ============================================
        class LanguageManager {
            constructor() {
                this.currentLang = 'uk';
                this.init();
            }
            
            init() {
                const savedLang = localStorage.getItem('ultimateTicTacToeLang');
                if (savedLang) {
                    this.currentLang = savedLang;
                }
                
                this.setupEventListeners();
                this.applyLanguage();
            }
            
            setupEventListeners() {
                const langButtons = document.querySelectorAll('.lang-btn');
                langButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const lang = btn.dataset.lang;
                        this.setLanguage(lang);
                    });
                });
            }
            
            setLanguage(lang) {
                this.currentLang = lang;
                localStorage.setItem('ultimateTicTacToeLang', lang);
                this.applyLanguage();
                
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
            }
            
            applyLanguage() {
                const elements = document.querySelectorAll('[data-uk], [data-en]');
                elements.forEach(element => {
                    if (element.dataset[this.currentLang]) {
                        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                            element.placeholder = element.dataset[this.currentLang];
                        } else {
                            element.textContent = element.dataset[this.currentLang];
                        }
                    }
                });
            }
            
            getText(ukText, enText) {
                return this.currentLang === 'uk' ? ukText : enText;
            }
        }

        // ============================================
        // SOUND GENERATOR
        // ============================================
        class SoundGenerator {
            constructor() {
                this.audioContext = null;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log("Web Audio API –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è");
                }
            }
            
            playTone(frequency, duration, type = 'sine', volume = 0.15) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            playPlaceX() {
                this.playTone(523.25, 0.1, 'square');
            }
            
            playPlaceO() {
                this.playTone(392.00, 0.1, 'triangle');
            }
            
            playWinLocal() {
                this.playTone(659.25, 0.15, 'square');
            }
            
            playWinGlobal() {
                this.playTone(523.25, 0.1, 'square');
                setTimeout(() => this.playTone(659.25, 0.1, 'square'), 100);
                setTimeout(() => this.playTone(783.99, 0.2, 'square'), 200);
            }
            
            playAIMove() {
                this.playTone(349.23, 0.1, 'sawtooth');
            }

            playAIThinking() {
                this.playTone(261.63, 0.05, 'sine', 0.1);
                setTimeout(() => this.playTone(293.66, 0.05, 'sine', 0.1), 50);
                setTimeout(() => this.playTone(329.63, 0.05, 'sine', 0.1), 100);
            }
        }

        // ============================================
        // ULTIMATE TIC-TAC-TOE GAME WITH MCTS AI
        // ============================================
        class UltimateTicTacToe {
            constructor() {
                this.localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
                this.localBoardsStatus = Array(9).fill('');
                this.globalBoard = Array(9).fill('');
                
                this.currentPlayer = 'X';
                this.activeBoard = null;
                this.gameOver = false;
                this.scores = { X: 0, O: 0 };
                
                this.gameMode = 'twoPlayers';
                this.aiDifficulty = 'medium';
                this.aiThinking = false;
                
                this.languageManager = new LanguageManager();
                this.sound = new SoundGenerator();
                this.mctsAI = new MCTSPlayer(this.aiDifficulty);
                
                this.init();
            }
            
            init() {
                this.drawBoard();
                this.setupEventListeners();
                this.updateStatus();
                this.loadScores();
            }
            
            drawBoard() {
                const megaBoard = document.getElementById('megaBoard');
                megaBoard.innerHTML = '';
                
                for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                    const localBoard = document.createElement('div');
                    localBoard.className = 'local-board';
                    localBoard.dataset.boardIndex = boardIndex;
                    
                    const status = this.localBoardsStatus[boardIndex];
                    if (status === 'X') {
                        localBoard.classList.add('won', 'won-x');
                        localBoard.dataset.winner = 'X';
                    } else if (status === 'O') {
                        localBoard.classList.add('won', 'won-o');
                        localBoard.dataset.winner = 'O';
                    } else if (status === 'tie') {
                        localBoard.classList.add('tied');
                    }
                    
                    if (this.activeBoard === null || this.activeBoard === boardIndex) {
                        if (status === '' && !this.gameOver) {
                            localBoard.classList.add('active');
                        }
                    }
                    
                    for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.boardIndex = boardIndex;
                        cell.dataset.cellIndex = cellIndex;
                        
                        const cellValue = this.localBoards[boardIndex][cellIndex];
                        if (cellValue) {
                            cell.textContent = cellValue;
                            cell.classList.add(cellValue.toLowerCase());
                        }
                        
                        const isActiveBoard = this.activeBoard === null || this.activeBoard === boardIndex;
                        const isBoardAvailable = status === '';
                        
                        if (!isActiveBoard || !isBoardAvailable || cellValue || this.gameOver) {
                            cell.classList.add('disabled');
                        }
                        
                        if (this.gameMode === 'vsAI' && this.currentPlayer === 'O' && !this.gameOver) {
                            cell.classList.add('disabled');
                        }
                        
                        cell.addEventListener('click', () => this.handleCellClick(boardIndex, cellIndex));
                        localBoard.appendChild(cell);
                    }
                    
                    megaBoard.appendChild(localBoard);
                }
            }
            
            handleCellClick(boardIndex, cellIndex) {
                if (this.gameOver) return;
                if (this.localBoards[boardIndex][cellIndex] !== '') return;
                if (this.localBoardsStatus[boardIndex] !== '') return;
                if (this.activeBoard !== null && this.activeBoard !== boardIndex) return;
                
                if (this.gameMode === 'vsAI' && this.currentPlayer === 'O') return;
                
                this.makeMove(boardIndex, cellIndex);
            }
            
            makeMove(boardIndex, cellIndex) {
                this.localBoards[boardIndex][cellIndex] = this.currentPlayer;
                
                this.currentPlayer === 'X' ? this.sound.playPlaceX() : this.sound.playPlaceO();
                
                if (navigator.vibrate) navigator.vibrate(10);
                
                const localWinner = this.checkLocalBoardWinner(boardIndex);
                if (localWinner) {
                    this.localBoardsStatus[boardIndex] = localWinner;
                    this.globalBoard[boardIndex] = localWinner;
                    this.sound.playWinLocal();
                    
                    const globalWinner = this.checkGlobalWinner();
                    if (globalWinner) {
                        this.handleGameWin(globalWinner);
                        this.drawBoard();
                        return;
                    }
                } else if (this.isLocalBoardFull(boardIndex)) {
                    this.localBoardsStatus[boardIndex] = 'tie';
                }
                
                const nextBoard = cellIndex;
                if (this.localBoardsStatus[nextBoard] === '') {
                    this.activeBoard = nextBoard;
                } else {
                    this.activeBoard = null;
                }
                
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                
                this.drawBoard();
                this.updateStatus();
                
                if (this.gameMode === 'vsAI' && this.currentPlayer === 'O' && !this.gameOver) {
                    this.makeAIMove();
                }
            }

            createMCTSState() {
                return new MCTSGameState(
                    this.localBoards,
                    this.localBoardsStatus,
                    this.currentPlayer,
                    this.activeBoard
                );
            }
            
            makeAIMove() {
                if (this.aiThinking) return;
                this.aiThinking = true;

                const statusElement = document.getElementById('status');
                const playerIcon = document.querySelector('.player-icon');
                const progressBar = document.getElementById('aiProgress');
                const progressBarInner = document.getElementById('aiProgressBar');
                const progressText = document.getElementById('progressText');

                statusElement.textContent = this.languageManager.getText(
                    'ü§ñ AI –∞–Ω–∞–ª—ñ–∑—É—î –ø–æ–∑–∏—Ü—ñ—é...',
                    'ü§ñ AI analyzing position...'
                );
                statusElement.classList.add('ai-thinking');
                progressBar.style.display = 'block';

                playerIcon.classList.add('ai-thinking');
                playerIcon.textContent = 'ü§ñ';

                this.sound.playAIThinking();

                const gameState = this.createMCTSState();
                
                const progressCallback = (progress, iterations) => {
                    progressBarInner.style.width = `${progress}%`;
                    progressText.textContent = this.languageManager.getText(
                        `AI –∞–Ω–∞–ª—ñ–∑—É—î... ${iterations} —ñ—Ç–µ—Ä–∞—Ü—ñ–π`,
                        `AI analyzing... ${iterations} iterations`
                    );
                };

                setTimeout(() => {
                    try {
                        const aiMove = this.mctsAI.getMove(gameState, progressCallback);
                        
                        if (aiMove) {
                            this.sound.playAIMove();
                            this.makeMove(aiMove.boardIndex, aiMove.cellIndex);
                        } else {
                            const availableMoves = this.getAvailableMoves();
                            if (availableMoves.length > 0) {
                                const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                                this.makeMove(randomMove.boardIndex, randomMove.cellIndex);
                            }
                        }
                    } catch (error) {
                        console.error('AI move error:', error);
                        const availableMoves = this.getAvailableMoves();
                        if (availableMoves.length > 0) {
                            const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                            this.makeMove(randomMove.boardIndex, randomMove.cellIndex);
                        }
                    }

                    statusElement.classList.remove('ai-thinking');
                    playerIcon.classList.remove('ai-thinking');
                    progressBar.style.display = 'none';
                    this.aiThinking = false;
                }, 100);
            }

            getAvailableMoves() {
                const moves = [];
                const playableBoards = this.activeBoard === null ? 
                    this.localBoardsStatus.map((status, index) => status === '' ? index : -1).filter(i => i !== -1) :
                    [this.activeBoard];
                
                playableBoards.forEach(boardIndex => {
                    if (this.localBoardsStatus[boardIndex] === '') {
                        for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                            if (this.localBoards[boardIndex][cellIndex] === '') {
                                moves.push({ boardIndex, cellIndex });
                            }
                        }
                    }
                });
                return moves;
            }
            
            checkLocalBoardWinner(boardIndex) {
                const board = this.localBoards[boardIndex];
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                
                for (const [a, b, c] of patterns) {
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a];
                    }
                }
                return null;
            }
            
            isLocalBoardFull(boardIndex) {
                return this.localBoards[boardIndex].every(cell => cell !== '');
            }
            
            checkGlobalWinner() {
                const patterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                
                for (const [a, b, c] of patterns) {
                    if (this.globalBoard[a] && 
                        this.globalBoard[a] === this.globalBoard[b] && 
                        this.globalBoard[a] === this.globalBoard[c]) {
                        return this.globalBoard[a];
                    }
                }
                
                if (this.localBoardsStatus.every(status => status !== '')) {
                    return 'tie';
                }
                
                return null;
            }
            
            handleGameWin(winner) {
                this.gameOver = true;
                
                if (winner !== 'tie') {
                    this.scores[winner]++;
                    this.saveScores();
                    this.updateScores();
                    this.sound.playWinGlobal();
                    
                    if (navigator.vibrate) {
                        navigator.vibrate([100, 50, 100, 50, 200]);
                    }
                    
                    this.updateStatus(
                        this.languageManager.getText(
                            `üéâ –ì—Ä–∞–≤–µ—Ü—å ${winner} –≤–∏–≥—Ä–∞–≤ –≥—Ä—É!`,
                            `üéâ Player ${winner} wins!`
                        ),
                        true
                    );
                } else {
                    this.updateStatus(
                        this.languageManager.getText('ü§ù –ì–ª–æ–±–∞–ª—å–Ω–∞ –Ω—ñ—á–∏—è!', 'ü§ù Game tied!'),
                        true
                    );
                }
            }
            
            updateStatus(message = null, isWin = false) {
                const statusElement = document.getElementById('status');
                const playerIcon = document.querySelector('.player-icon');
                const playerText = document.getElementById('currentPlayerText');
                
                if (message) {
                    statusElement.textContent = message;
                    if (isWin) {
                        statusElement.classList.add('win');
                    }
                    return;
                }
                
                statusElement.classList.remove('win', 'ai-thinking');
                playerIcon.className = 'player-icon';
                playerIcon.classList.add(this.currentPlayer === 'X' ? 'player-x' : 'player-o');
                playerIcon.textContent = this.currentPlayer;
                
                playerText.textContent = this.languageManager.getText(
                    `–ì—Ä–∞–≤–µ—Ü—å ${this.currentPlayer}`,
                    `Player ${this.currentPlayer}`
                );
                
                if (this.activeBoard === null) {
                    statusElement.textContent = this.languageManager.getText(
                        `–ì—Ä–∞–≤–µ—Ü—å ${this.currentPlayer} –º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ —Ö—ñ–¥ –≤ –±—É–¥—å-—è–∫—ñ–π –¥–æ—à—Ü—ñ`,
                        `Player ${this.currentPlayer} can move in any board`
                    );
                } else {
                    const row = Math.floor(this.activeBoard / 3) + 1;
                    const col = (this.activeBoard % 3) + 1;
                    statusElement.textContent = this.languageManager.getText(
                        `–ì—Ä–∞–≤–µ—Ü—å ${this.currentPlayer} –ø–æ–≤–∏–Ω–µ–Ω –≥—Ä–∞—Ç–∏ –≤ –¥–æ—à—Ü—ñ ${row}√ó${col}`,
                        `Player ${this.currentPlayer} must play in board ${row}√ó${col}`
                    );
                }
            }
            
            updateScores() {
                document.getElementById('scoreX').textContent = this.scores.X;
                document.getElementById('scoreO').textContent = this.scores.O;
            }
            
            saveScores() {
                window.ultimateScores = this.scores;
            }
            
            loadScores() {
                if (window.ultimateScores) {
                    this.scores = window.ultimateScores;
                    this.updateScores();
                }
            }
            
            setGameMode(mode) {
                this.gameMode = mode;
                const difficultySelector = document.getElementById('difficultySelector');
                
                if (mode === 'vsAI') {
                    difficultySelector.style.display = 'flex';
                } else {
                    difficultySelector.style.display = 'none';
                }
                
                this.resetGame();
            }
            
            setAIDifficulty(difficulty) {
                this.aiDifficulty = difficulty;
                this.mctsAI.setDifficulty(difficulty);
            }
            
            resetGame() {
                this.localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
                this.localBoardsStatus = Array(9).fill('');
                this.globalBoard = Array(9).fill('');
                this.currentPlayer = 'X';
                this.activeBoard = null;
                this.gameOver = false;
                this.aiThinking = false;
                
                const progressBar = document.getElementById('aiProgress');
                progressBar.style.display = 'none';
                
                this.drawBoard();
                this.updateStatus();
            }
            
            setupEventListeners() {
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetGame();
                });
                
                document.getElementById('rulesBtn').addEventListener('click', () => {
                    this.showTutorial();
                });
                
                document.getElementById('tutorialBtn').addEventListener('click', () => {
                    this.showTutorial();
                });
                
                document.getElementById('closeModal').addEventListener('click', () => {
                    this.hideTutorial();
                });
                
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setGameMode(btn.dataset.mode);
                    });
                });
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setAIDifficulty(btn.dataset.diff);
                    });
                });
                
                document.getElementById('tutorialModal').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialModal') {
                        this.hideTutorial();
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideTutorial();
                    }
                });
            }
            
            showTutorial() {
                document.getElementById('tutorialModal').classList.add('active');
            }
            
            hideTutorial() {
                document.getElementById('tutorialModal').classList.remove('active');
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            const game = new UltimateTicTacToe();
            
            window.ultimateGame = game;
            
            console.log('%cüéÆ ULTIMATE TIC-TAC-TOE', 'color: #0ff; font-size: 20px; font-weight: bold;');
            console.log('%c‚ö° Cyberpunk Edition with Advanced MCTS AI', 'color: #f0f; font-size: 16px;');
            console.log('%cGame object available as window.ultimateGame', 'color: #0f0; font-size: 12px;');
        });
    </script>
</body>
</html>
